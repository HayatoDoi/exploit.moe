package md2article

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/HayatoDoi/exploit.moe/DB"
)

type flagStruct struct {
	pramLoad bool
	aTag     bool
}

type Arts struct {
	Filename string
	Art      DB.Article
}

func LoadDir(dir string) ([]Arts, error) {
	arts := []Arts{}
	dirs := dirwalk(dir)
	for fname, dir := range dirs {
		art, err := LoadFile(dir)
		if err != nil {
			return arts, err
		}
		arts = append(arts, Arts{fname, art})
	}
	return arts, nil
}

func LoadFile(file string) (DB.Article, error) {
	fmt.Println(file)
	art := DB.Article{}
	fp, err := os.Open(file)
	if err != nil {
		return art, err
	}
	defer fp.Close()
	flag := flagStruct{}
	reader := bufio.NewReaderSize(fp, 4096)
	for i := 1; ; i++ {
		line, _, err := reader.ReadLine()
		// Load article parameters
		//--------------------------------------------------------
		if i == 1 && string(line) == "---" {
			flag.pramLoad = true
			continue
		}
		if flag.pramLoad == true && string(line) == "---" {
			flag.pramLoad = false
			continue
		}
		if flag.pramLoad == true {
			r := regexp.MustCompile(`(\S+):`)
			result := r.FindStringSubmatch(string(line))
			if len(result) == 2 {
				if err := convertArticlePram(result[0], string(line), &art); err != nil {
					return art, errorPrint(i, string(line), err.Error())
				}
			}
		} else {
			loadBody(string(line), &art, &flag)
		}

		if err == io.EOF {
			break
		} else if err != nil {
			return art, err
		}
	}
	return art, nil
}

func dirwalk(dir string) map[string]string {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		panic(err)
	}

	paths := map[string]string{}
	for _, file := range files {
		paths[file.Name()] = filepath.Join(dir, file.Name())
	}

	return paths
}

func errorPrint(lineNum int, line string, msg string) error {
	msg = fmt.Sprintf("%s\n%d| %s", msg, lineNum, line)
	return errors.New(msg)
}

func convertArticlePram(key string, line string, art *DB.Article) error {
	rep := regexp.MustCompile(`(\S+):\s*`)
	line = rep.ReplaceAllString(line, "")
	if key == "date:" {
		data, err := time.Parse("2006-01-02", line)
		if err != nil {
			return err
		}
		art.Date = data
	} else if key == "title:" {
		art.Title = line
	} else if key == "tags:" {
		rep := regexp.MustCompile(`^\[.*\]$`)
		str := rep.FindStringSubmatch(line)[0]
		str = string([]rune(str)[1 : len([]rune(str))-1]) //remove []
		tags := strings.Split(str, ",")
		for i := 0; i < len(tags); i++ {
			tags[i] = strings.TrimSpace(tags[i])
		}
		art.Tags = tags
	} else if key == "public:" {
		if line == "true" {
			art.Public = true
		} else if line == "false" {
			art.Public = false
		} else {
			return errors.New("Unkown Parameter.")
		}
	} else if key == "excerpt:" {
		fmt.Println(line)
		art.Excerpt = line
	}
	return nil
}

func loadBody(line string, art *DB.Article, flag *flagStruct) error {
	art.Text = art.Text + line + "\n"
	return nil
}
